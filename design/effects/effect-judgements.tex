\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb} % needed for \varnothing
\usepackage[english]{babel}
\usepackage[margin=.9in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{proof}
\usepackage{relsize} % make maths formulae larger
\usepackage{stackengine}
\usepackage{calc}

\lstset{tabsize=3, basicstyle=\ttfamily\small, commentstyle=\itshape\rmfamily, numbers=left, numberstyle=\tiny, language=java,moredelim=[il][\sffamily]{?},mathescape=true,showspaces=false,showstringspaces=false,columns=fullflexible,xleftmargin=5pt,escapeinside={(@}{@)}, morekeywords=[1]{objtype,module,import,let,in,fn,var,type,rec,fold,unfold,letrec,alloc,ref,application,policy,external,component,connects,to,meth,val,where,return,group,by,within,count,connect,with,attr,html,head,title,style,body,div,keyword,unit,def}}
\lstloadlanguages{Java,VBScript,XML,HTML}


\newcommand{\keywadj}[1]{\mathtt{#1}}
\newcommand{\keyw}[1]{\keywadj{#1}~}

\begin{document}

\section{Grammar}

We denote the set of methods in a program by $M$ and the set of resources by $R$. A resource has the authority to directly perform I/O operations. Elements of those sets are denoted $m$ and $r$ respectively. An effect is a member of the set of pairs $M \times R$. Intuitively we may read the effect $(m,r)$ as meaning 'the effect on resource $r$ when method $m$ is called'. A set of effects is denoted by $\varepsilon$.

\[
\begin{array}{lll}

\begin{array}{lllr}
e & ::= & x & expressions \\
  & | & \keywadj{new}~x \Rightarrow \overline{\sigma = e} \\
  & | & e.m(e)\\
  & | & r \\
&&\\

\tau & ::= & \{ \overline{\sigma} \} ~ | ~ \{ \overline r \} & types \\

\\d & ::= & \keyw{def} m(x:\tau):\tau & declarations\\
&&\\

\sigma & ::= & d~\keyw{with}\varepsilon  & annotated~ decls.\\
&&\\

\gamma & ::= & \{ \bar d~\keyw{captures} \varepsilon \} & annotated~decls.\\
&&\\

\kappa & ::= & d = e~\keyw{OK} & well~formed~decls. \\
  & | & \sigma = e~\keyw{OK}\\
\end{array}
& ~~~~~~
&
\end{array}
\]

\section{Effect Rules (Green)}

\[
\begin{array}{c}
\infer[\textsc{($\varepsilon$-Var)}]
  {\Gamma, x:\tau \vdash x:\tau~ \keyw{with} \varnothing}
  {} 
~~~~~~~~~~
\infer[\textsc{($\varepsilon$-Resource)}]
  {\Gamma \vdash r:\{ r \} ~ \keyw{with} \varnothing}
  {} \\[5ex]

\infer[\textsc{($\varepsilon$-ValidImpl)}]
	{\Gamma \vdash \sigma = e~\keywadj{OK}}
	{\Gamma, x:\tau \vdash e: \tau'~\keyw{with} \varepsilon & \sigma = \keyw{def} m(x:\tau):\tau'~\keyw{with} \varepsilon} \\[5ex]

\infer[\textsc{($\varepsilon$-NewObj)}]
	{\Gamma \vdash \keywadj{new}~x \Rightarrow \overline{\sigma = e} : \{ \bar \sigma \}~\keyw{with} \varnothing}
	{\Gamma, x : \{ \bar \sigma \} \vdash \overline{\sigma = e}~\keywadj{OK}} \\[5ex]

\infer[\textsc{($\varepsilon$-MethCallResource)}]
	{\Gamma \vdash e_1.m(e_2) : \{ \bar r \}~\keyw{with} \{ \bar r, m\} \cup \varepsilon_1 \cup \varepsilon_2}
	{\Gamma \vdash e_1 : \{ \bar r \}~ \keyw{with} \varepsilon_1 & \Gamma \vdash e_2:\tau_2~\keyw{with} \varepsilon_2} \\[5ex]
	
\infer[\textsc{($\varepsilon$-MethCallObj)}]
	{\Gamma \vdash e_1.m_i(e_2):\tau~\keyw{with} \varepsilon_1 \cup \varepsilon_2 \cup \varepsilon}
	{\Gamma \vdash e_1 : \{ \bar \sigma \}~\keyw{with} \varepsilon_1 & \Gamma \vdash e_2 : \tau_2~\keyw{with} \varepsilon_2 & \sigma_i := \keyw{def} m_i(y:\tau_2):\tau~\keyw{with} \varepsilon}

\end{array}
\]

\noindent \textbf{Notes:}

\begin{itemize}
	\item The $\varepsilon$ judgements are to be applied to portions of the program where the methods are explicitly annotated with their effects.
	\item The rules \textsc{$\varepsilon$-Var}, \textsc{$\varepsilon$-Resource}, and \textsc{$\varepsilon$-NewObj} have in their antecedents an expression typed with no effect. Merely having an object or resource is not an effect; you must do something with it, like a call a method on it, in order for your program to have effects.
	\item \textsc{$\varepsilon$-ValidImpl} says that the return type and effects of the body of a method must agree with what its signature says.
	\item According to \textsc{$\varepsilon$-MethCallResource}, we can call any method on a resource. Doing so returns that same resource.
\end{itemize}


\section{Capture Rules (Orange)}

\[
\begin{array}{c}

\infer[\textsc{(C-NewObj)}]
	{\Gamma \vdash~\keywadj{new}~x \Rightarrow \overline{d = e} : \{  \bar d~\keyw{captures} \varepsilon \} }
	{\varepsilon = effects(\Gamma') & \Gamma' \subseteq \Gamma & \Gamma', x : \{ \bar d~\keyw {captures} \varepsilon \} \vdash \overline{d = e}~\keyw{OK}} \\[5ex]

\infer[\textsc{(C-MethCall)}]
	{\Gamma \vdash e_1.m_i(e_2) : \tau~ \keyw{with} \varepsilon_1 \cup \varepsilon_2 \cup effects(\tau_2)}
	{\Gamma \vdash e_1 : \{ \bar d~\keyw{captures} \varepsilon \}~\keyw{with} \varepsilon_1 & \Gamma \vdash e_2:\tau_2~\keyw{with} \varepsilon_2&d_i :=~\keyw{def} m_i(y:\tau_2):\tau }

\end{array}
\]

\begin{itemize}
	\item The capture judgements are to be applied when the program is not explicitly annotated with their effects. These rules perform a conservative effect analysis.
	\item The rule \textsc{C-NewObj} takes unnannotated methods and labels them using the $\keywadj{captures}$ keyword. Whereas $d~\keyw{with} \varepsilon$ means that execution of the method defined by $d$ has the effects $\varepsilon$, $d~\keyw{captures} \varepsilon$ means that $d$ has the authority to perform the effects $\varepsilon$, though it may not actually do so. We can think of $\keywadj{captures}$ as an upper bound on the effects of a program, and $\keywadj{with}$ as a tight upper bound.
	\item \textsc{C-MethCall} performs a conservative effect analysis by concluding the effects of an expression to be those effects which it captures.
\end{itemize}

\subsection{Definition of effects function}

The $effects$ function returns the set of effects of an expression as determined by our calculus thus far in a certain typing context. It recurses on sub-expressions, looking for effect annotations. If a declaration does not have an effect annotation then the function returns the set of effects captured is returned.

\begin{itemize}
	\item $effects(\cdot) = \varnothing$
	\item $effects(\{\bar r\}) = \{ (r, m) \mid r \in \bar r, m \in M \}$
	\item $effects(\{ \bar d~\keyw{captures} \varepsilon \}) = \varepsilon$
	\item $effects( \{ \bar \sigma \}) = \bigcup_{\sigma \in \bar \sigma}~effects(\sigma)$
	\item $effects(d~\keyw{with} \varepsilon) = \varepsilon$
\end{itemize}

\end{document}