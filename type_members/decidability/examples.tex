\documentclass{llncs}

\usepackage{listings}
\usepackage{amssymb}
\usepackage[margin=.9in]{geometry}
\usepackage{amsmath}
%\usepackage{amsthm}
\usepackage{mathpartir}
\usepackage{color,soul}
\usepackage{graphicx}

\setcounter{secnumdepth}{5}

%\theoremstyle{definition}
%%\newtheorem{case1}{Case1}
\spnewtheorem{casethm}{Case}[theorem]{\itshape}{\rmfamily}
\spnewtheorem{subcase}{Subcase}{\itshape}{\rmfamily}
\numberwithin{subcase}{casethm}
\numberwithin{casethm}{theorem}
\numberwithin{casethm}{lemma}





\lstdefinestyle{custom_lang}{
  xleftmargin=\parindent,
  showstringspaces=false,
  basicstyle=\ttfamily,
  keywordstyle=\bfseries
}

\lstset{emph={%  
    val, def, type, new, z%
    },emphstyle={\bfseries \tt}%
}

\begin{document}

\section{Equatable}
\subsection{Java: Cyclic Proofs}


\begin{lstlisting}[mathescape, style=custom_lang]
interface Equatable<T extends Object>{}

interface List<T extends Object> extends 
                     Equatable<List<? extends Equatable<? super T>>>{}

class ArrayList<T extends Object> implements List<T>{}

class Tree extends ArrayList<Tree>{}

public class Function{
  public void func(Equatable<? super Tree> e){
     ...
  }

Tree t = new Tree();
Function f = new Function();

f.func(t);
\end{lstlisting}
Is \verb|Tree| a subtype of \verb|Equatable<? super Tree>|?
\begin{mathpar}
\inferrule
 {\texttt{Tree} <:\texttt{Equatable<? super Tree>}}
 {}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\Downarrow}
 {}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\texttt{ArrayList<Tree>} <:\texttt{Equatable<? super Tree>}}
 {}
 \quad{\emph{inheritance}}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\Downarrow}
 {}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\texttt{List<Tree>} <:\texttt{Equatable<? super Tree>}}
 {}
 \quad{\emph{inheritance}}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\Downarrow}
 {}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\texttt{Equatable<List<? extends Equatable<? super Tree>>>} <:\texttt{Equatable<? super Tree>}}
 {}
 \quad{\emph{inheritance}}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\Downarrow}
 {}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\texttt{Tree} <:\texttt{List<? extends Equatable<? super Tree>>}}
 {}
 \quad{\emph{contravariance}}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\Downarrow}
 {}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\texttt{ArrayList<Tree>} <:\texttt{List<? extends Equatable<? super Tree>>}}
 {}
 \quad{\emph{inheritance}}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\Downarrow}
 {}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\texttt{List<Tree>} <:\texttt{List<? extends Equatable<? super Tree>>}}
 {}
 \quad{\emph{inheritance}}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\Downarrow}
 {}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\texttt{Tree} <:\texttt{Equatable<? super Tree>}}
 {}
 \quad{\emph{covariance}}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\Downarrow}
 {}
\end{mathpar}
\begin{mathpar}
\inferrule
 {.\\\\
  .\\\\
  .}
 {}
\end{mathpar}

\newpage

\subsection{Java: Acyclic Proofs}


\begin{lstlisting}[mathescape, style=custom_lang]
class List<T> extends Equatable<Equatable<? super List<List<T>>>>{}
\end{lstlisting}
Is \verb|List<Integer>| a subtype of \verb|Equatable<? super List<Integer>>|?
\begin{mathpar}
\inferrule
 {\texttt{List<Integer>} <:\texttt{Equatable<? super List<Integer>>}}
 {}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\Downarrow}
 {}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\texttt{Equatable<Equatable<? super List<List<Intger>>>>} <:\texttt{Equatble<? super List<Integer>>}}
 {}
 \quad{\emph{inheritance}}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\Downarrow}
 {}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\texttt{List<Integer>} <:\texttt{Equatable<? super List<List<Integer>>>}}
 {}
 \quad{\emph{contravariance}}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\Downarrow}
 {}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\texttt{Equatble<Equatable<? super List<List<Integer>>>>} <:\texttt{Equatable<? super List<List<Integer>>>}}
 {}
 \quad{\emph{inheritance}}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\Downarrow}
 {}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\texttt{List<List<Integer>>} <:\texttt{Equatable<? super List<List<Integer>>>}}
 {}
 \quad{\emph{contravariance}}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\Downarrow}
 {}
\end{mathpar}
\begin{mathpar}
\inferrule
 {.\\\\
  .\\\\
  .}
 {}
\end{mathpar}

\newpage

\subsection{Wyvern}

%\begin{lstlisting}[mathescape, style=custom_lang]
%class Equatable[E] {
%    def equals(E other): boolean
%}
%def myFunction[T](T t1, Equatable[T] t2) { ... equals(t1, t2); }
%def myFunctions[T <: Equatable[T]](T t1, T t2) { ... equals(t1, t2); }
%def myFunction[T](T t1, Equatable[T] t2) { ... t2.equals(t1); }
%Section 5.1: Equatable, List, Tree
%type Equatable
%    type E
%    def equals(other:E):boolean
%// Java's List class, simplified
%class List<out E> extends Equable<List<E>> {
%    E pick();
%    boolean equals(other:List<E>);
%} 
%// in Wyvern
%type List
%    type T: bottom .. Equatable[E = this.T]
%    type E = List[T = this.T, E = this.E]
%    def pick():T
%    def equals(E other):boolean
%// in Wyvern, where List extends Equatable<List<Equatable<E>>>
%type List
%    type T: bottom .. Equatable[E = this.T]
%    type E = List[T = Equatable[T], E = ?]
%    def pick():T
%    def equals(E other):boolean
%// type E is probably this:
%type E = List[T = Equatable[T], E = this.T]
%type E = List[T = Equatable[T], E = this.E]
%type Tree
%    type T = List[T = this.T, E = this.E]
%    type T = Tree[T = this.T, E = this.E]
%    type E = Tree[T = List[Equatable[E]], E = this.E]
%    type E = Tree[T = Tree[Equatable[E]], E = this.E] // perhaps better?
%\end{lstlisting}

\begin{lstlisting}[mathescape, style=custom_lang]
{z$_0$ $\Rightarrow$
	type Equatable = {z$_1$ $\Rightarrow$
		type E = $\bot$ .. $\top$
		def equals(e : E) : boolean
	}
	
	type List = {z$_1$ $\Rightarrow$
		type E = $\bot$ .. z$_0$.Equatable $\wedge$ 
				{z$_2$ $\Rightarrow$ type E = $\bot$ .. List $\wedge$ 
				             {z$_3$ $\Rightarrow$ type E = z$_1$.E}}
		def equals(e : E) : boolean
	}

	type Tree =  z$_0$.List $\wedge$ {z$_1$ $\Rightarrow$ type E = $\bot$ .. z$_0$.Tree}
}
\end{lstlisting}
%Is \verb|Tree| a subtype of \verb|Equatable|$\wedge$\verb|{z|$_1 \Rightarrow$ \verb|type E = |$\bot$..\verb|z|$_0$.\verb|Tree}|?
\begin{mathpar}
\inferrule
 {z_0.\texttt{Tree} <:\texttt{Equatable}\wedge\{z_2 \Rightarrow \texttt{type E} = \bot .. \texttt{List} \wedge 
				             \{z_3 \Rightarrow \texttt{type E} = z_0.\texttt{List.E}\}\}}
 {}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\Downarrow}
 {}
\end{mathpar}
\begin{mathpar}
\inferrule
 {z_0.\texttt{Tree} <:\texttt{Equatable}\wedge\{z_2 \Rightarrow \texttt{type E} = \bot .. \texttt{List} \wedge 
				             \{z_3 \Rightarrow \texttt{type E} = z_2.E\}\}}
 {}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\Downarrow}
 {}
\end{mathpar}
%\begin{mathpar}
%\inferrule
% {\texttt{Equatable} \wedge 
%				\{z_2 \Rightarrow \texttt{type E} = \bot .. \texttt{z}_0.\texttt{Tree}\} <: \texttt{Tree}}
% {}
% \quad{(\emph{by covariance of the upper bound of } \texttt{E})}
%\end{mathpar}
%\begin{mathpar}
%\inferrule
% {\Downarrow}
% {}
%\end{mathpar}
%\begin{mathpar}
%\inferrule
% {\texttt{Tree} <:\texttt{Equatable}\wedge\{\texttt{z}_1 \Rightarrow \texttt{type E =} \bot .. \texttt{z}_0.\texttt{Tree}\}}
% {}
% \quad{(\emph{by covariance of the upper bound of } \texttt{E})}
%\end{mathpar}
%\begin{mathpar}
%\inferrule
% {\Downarrow}
% {}
%\end{mathpar}
%\begin{mathpar}
%\inferrule
% {.\\\\
%  .\\\\
%  .}
% {}
%\end{mathpar}

\newpage

\subsection{Wyvern: Acyclic Proofs}



\begin{lstlisting}[mathescape, style=custom_lang]
{z$_0$ $\Rightarrow$
	type Equatable = {z$_1$ $\Rightarrow$
		type E = $\bot$ .. $\top$
		def equals(e : E) : boolean
	}
	
	type List = {z$_1$ $\Rightarrow$
		type T = $\bot$ .. $\top$
		type E = $\bot$ .. z$_0$.Equatable $\wedge$ 
				{z$_2$ $\Rightarrow$ type E = z$_1$.T}
		def equals(e : E) : boolean
	}

	type Tree =  z$_0$.List $\wedge$ {z$_1$ $\Rightarrow$ type T = $\bot$ .. z$_0$.Tree}
}
\end{lstlisting}
\begin{lstlisting}[mathescape, style=custom_lang]
class List<T> extends Equatable<Equatable<? super List<List<T>>>>{}
\end{lstlisting}
Is \verb|List<Integer>| a subtype of \verb|Equatable<? super List<Integer>>|?
\begin{mathpar}
\inferrule
 {\texttt{List<Integer>} <:\texttt{Equatable<? super List<Integer>>}}
 {}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\Downarrow}
 {}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\texttt{Equatable<Equatable<? super List<List<Intger>>>>} <:\texttt{Equatble<? super List<Integer>>}}
 {}
 \quad{\emph{inheritance}}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\Downarrow}
 {}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\texttt{List<Integer>} <:\texttt{Equatable<? super List<List<Integer>>>}}
 {}
 \quad{\emph{contravariance}}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\Downarrow}
 {}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\texttt{Equatble<Equatable<? super List<List<Integer>>>>} <:\texttt{Equatable<? super List<List<Integer>>>}}
 {}
 \quad{\emph{inheritance}}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\Downarrow}
 {}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\texttt{List<List<Integer>>} <:\texttt{Equatable<? super List<List<Integer>>>}}
 {}
 \quad{\emph{contravariance}}
\end{mathpar}
\begin{mathpar}
\inferrule
 {\Downarrow}
 {}
\end{mathpar}
\begin{mathpar}
\inferrule
 {.\\\\
  .\\\\
  .}
 {}
\end{mathpar}

\newpage

%\begin{lstlisting}[mathescape, style=custom_lang]
%new world =>
%	type List = list =>
%		type E
%		// translation of List[Equatable[E]]
%		type ListEquatableE
%		type E = Equatable[list.E]
%		def equals(x:E):bool
%		// more here...
%			
%		def equals(x:List[Equatable[E]]):bool
%		def get():E
%// the rest is like equatable
%
%	type ArrayList = â€¦
%// analogous to list, maybe with one more member or something
%
%	type Tree
%		type E = Tree
%		// the rest is like List
%
%	type Equatable
%		type T
%		def equals(x:T):bool
%
%	EquatableTree
%		type T = Tree
%		def equals(x:this.T):bool
%
%	question: is world.Tree <: world.EquatableTree?
%
%
%
%
%List[Equatable[E] = List /\ {type E = Equatable /\ {type T = outerThis.E}}
%\end{lstlisting}
%
%\begin{lstlisting}[mathescape, style=custom_lang]
%class Equatable[E] {
%    def equals(E other): boolean
%}
%def myFunction[T](T t1, Equatable[T] t2) { ... equals(t1, t2); }
%def myFunctions[T <: Equatable[T]](T t1, T t2) { ... equals(t1, t2); }
%def myFunction[T](T t1, Equatable[T] t2) { ... t2.equals(t1); }
%Section 5.1: Equatable, List, Tree
%type Equatable
%    type E
%    def equals(other:E):boolean
%// Java's List class, simplified
%class List<out E> extends Equable<List<E>> {
%    E pick();
%    boolean equals(other:List<E>);
%}
%// in Wyvern
%type List
%    type T: bottom .. Equatable[E = this.T]
%    type E = List[T = this.T, E = this.E]
%    def pick():T
%    def equals(E other):boolean
%// in Wyvern, where List extends Equatable<List<Equatable<E>>>
%type List
%    type T: bottom .. Equatable[E = this.T]
%    type E = List[T = Equatable[T], E = ?]
%    def pick():T
%    def equals(E other):boolean
%// type E is probably this:
%type E = List[T = Equatable[T], E = this.T]
%type E = List[T = Equatable[T], E = this.E]
%type Tree
%    type T = List[T = this.T, E = this.E]
%    type T = Tree[T = this.T, E = this.E]
%    type E = Tree[T = List[Equatable[E]], E = this.E]
%    type E = Tree[T = Tree[Equatable[E]], E = this.E] // perhaps better?
%\end{lstlisting}


\bibliographystyle{plain}
\bibliography{bib}

\end{document}